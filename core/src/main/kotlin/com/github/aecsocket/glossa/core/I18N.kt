package com.github.aecsocket.glossa.core

import java.util.*

/**
 * An exception which occurs while generating a localized message.
 */
open class I18NException(message: String? = null, cause: Throwable? = null)
    : RuntimeException(message, cause)

/** The key for the current argument in a map scope. */
const val THIS_ARG = "_"
/** The key separating translation sections. */
const val I18N_SEPARATOR = "."

/**
 * A service which provides capabilities to localize a message based on a key and arguments.
 * An I18N service should be assumed to be immutable.
 *
 * @property locale The default locale that this instance generates messages with.
 * @param T The type of elements that are generated by translation operations.
 */
interface I18N<T> {
    val locale: Locale

    /**
     * Generates a translation for a given locale, key and arguments.
     */
    fun make(locale: Locale = this.locale, key: String, args: Argument.MapScope<T>.() -> Unit = {}): List<T>?

    /**
     * Generates a translation for a given key and arguments.
     * Uses the default [locale].
     */
    fun make(key: String, args: Argument.MapScope<T>.() -> Unit = {}) = make(locale, key, args)

    /**
     * Generates a translation for a given locale, key and arguments.
     * If the message could not be generated, generates a fallback message based on the implementation.
     */
    fun safe(locale: Locale = this.locale, key: String, args: Argument.MapScope<T>.() -> Unit = {}): List<T>

    /**
     * Generates a translation for a given key and arguments.
     * Uses the default [locale].
     * If the message could not be generated, generates a fallback message based on the implementation.
     */
    fun safe(key: String, args: Argument.MapScope<T>.() -> Unit = {}) = safe(locale, key, args)

    /**
     * Creates a new instance which uses this service as the underlying translator, but
     * changes the default locale used for translation.
     * @param locale The new default translation locale.
     */
    fun withLocale(locale: Locale): I18N<T> = object : I18N<T> {
        override val locale: Locale
            get() = locale

        override fun make(locale: Locale, key: String, args: Argument.MapScope<T>.() -> Unit) =
            this@I18N.make(locale, key, args)

        override fun safe(locale: Locale, key: String, args: Argument.MapScope<T>.() -> Unit) =
            this@I18N.safe(locale, key, args)
    }

    /**
     * A mutable builder which can build an I18N service.
     */
    interface Builder<T> {
        /**
         * Creates the I18N service with the specified arguments.
         */
        fun build(): I18N<T>

        /**
         * Registers a translation to this builder.
         */
        fun register(tl: Translation.Root)

        /**
         * Registers a translation to this builder, defined by the DSL.
         */
        fun register(locale: Locale, content: Translation.Scope.() -> Unit) = register(Translation.buildRoot(locale, content))
    }
}

/**
 * An I18N service which passes all operations to a backing I18N service.
 * @param backing The backing service.
 */
open class ForwardingI18N<T>(private val backing: I18N<T>) : I18N<T> {
    override val locale = backing.locale

    override fun make(locale: Locale, key: String, args: Argument.MapScope<T>.() -> Unit) =
        backing.make(locale, key, args)

    override fun safe(locale: Locale, key: String, args: Argument.MapScope<T>.() -> Unit) =
        backing.safe(locale, key, args)
}

/**
 * An object which can be localized into a list of [T]s.
 * @param T The type of elements that are generated by translation operations.
 */
interface Localizable<T> {
    /**
     * Translates this object into a list of [T]s.
     * Callers should pass an I18N which reflects the current locale being generated for,
     * using [I18N.withLocale].
     */
    fun localize(i18n: I18N<T>): List<T>
}
