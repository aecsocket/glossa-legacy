package com.github.aecsocket.glossa.core

/**
 * An argument which will be replaced when generating a list of tokens.
 * @param T The type of elements that are generated by the translation operation this argument is a part of.
 */
sealed interface Argument<T> {
    /**
     * The state of an argument while it is being used to generate tokens.
     * @param T The type of elements that are generated by the translation operation this argument state is a part of.
     */
    interface State<T> {
        /** The backing argument. */
        val backing: Argument<T>
    }

    /**
     * Creates an empty state for this argument.
     */
    fun createState(): State<T>

    /**
     * Creates an argument.
     * @param T The type of elements that are generated by the translation operation this argument factory is a part of.
     */
    interface Factory<T> {
        /** A human-readable name of the type of factory this is. */
        val name: String

        /**
         * Creates an argument.
         */
        fun create(): Argument<T>

        /** For `@key{...}`. */
        fun interface Raw<T> : Factory<T> {
            override val name: String
                get() = "raw"
            override fun create(): Argument.Raw<T>
        }

        /** For `@key(...)`. */
        fun interface Substitution<T> : Factory<T> {
            override val name: String
                get() = "substitution"
            override fun create(): Argument.Substitution<T>
        }

        /** For `@key[...]`. */
        fun interface Scoped<T> : Factory<T> {
            override val name: String
                get() = "scoped"
            override fun create(): Argument.Scoped<T>
        }
    }

    /** For `@key{...}`. */
    data class Raw<T>(val value: Any): Argument<T> {
        inner class State : Argument.State<T> {
            override val backing: Raw<T>
                get() = this@Raw
        }

        override fun createState() = State()
    }

    /** For `@key(...)`. */
    data class Substitution<T>(val value: T): Argument<T> {
        inner class State : Argument.State<T> {
            override val backing: Substitution<T>
                get() = this@Substitution
        }

        override fun createState() = State()
    }

    /** For `@key[...]`. */
    sealed interface Scoped<T> : Argument<T>

    data class ArgMap<T>(val args: Map<String, Factory<T>>): Scoped<T> {
        operator fun get(key: String) = args[key]

        inner class State : Argument.State<T> {
            override val backing: ArgMap<T>
                get() = this@ArgMap

            private val cache = HashMap<String, Argument.State<T>?>()

            fun backing(key: String) = args[key]

            // any factories we cache here, should be the same type when they come out
            @Suppress("UNCHECKED_CAST")
            fun <S : Argument.State<T>> compute(key: String, value: Factory<T>): S =
                cache.computeIfAbsent(key) { value.create().createState() } as S

            fun compute(key: String) = cache.computeIfAbsent(key) { args[key]?.create()?.createState() }
        }

        override fun createState() = State()
    }

    data class ArgList<T>(val args: List<Argument<T>>): Scoped<T> {
        inner class State : Argument.State<T> {
            override val backing: ArgList<T>
                get() = this@ArgList

            private val cache: ArrayList<Argument.State<T>>? = null

            fun compute(): List<Argument.State<T>> = cache ?: this@ArgList.args.map { it.createState() }
        }

        override fun createState() = State()
    }

    companion object {
        /**
         * Builds a map argument from a scope.
         */
        fun <T> buildMap(i18n: I18N<T>, value: MapScope<T>.() -> Unit): ArgMap<T> {
            val args = HashMap<String, Factory<T>>()
            value(MapScope(i18n) { k, v -> args[Keys.validate(k)] = v })
            return ArgMap(args)
        }

        /**
         * Builds a list argument from a scope.
         */
        fun <T> buildList(i18n: I18N<T>, value: ListScope<T>.() -> Unit): ArgList<T> {
            val args = ArrayList<Argument<T>>()
            value(ListScope(i18n, args::add))
            return ArgList(args)
        }

        /**
         * Generates an argument map with the only mapping being [THIS_ARG] to [value].
         */
        fun <T> single(value: Factory<T>) = ArgMap(mapOf(THIS_ARG to value))
    }

    /**
     * A context object used to create arguments.
     * This can also be used to generate sub-translations.
     * @param T The type of elements that are generated by the translation operation this argument scope is a part of.
     */
    sealed class Scope<T>(
        i18n: I18N<T>
    ) : ForwardingI18N<T>(i18n) {
        /** For `@key{...}`. */
        fun rawArg(value: Any) = Raw<T>(value)

        /** For `@key(...)`. */
        fun subArg(value: T) = Substitution(value)

        /** For `@key[@_()]`. */
        fun tlArg(value: Localizable<T>) = ArgList(value.localize(this).map { subArg(it) })

        /** For `@key[...]`. */
        fun mapArg(value: MapScope<T>.() -> Unit) = buildMap(this, value)

        /** For `@key[...]`. */
        fun listArg(value: ListScope<T>.() -> Unit) = buildList(this, value)
    }

    // all lazy loaded
    class MapScope<T>(
        i18n: I18N<T>,
        val add: (String, Factory<T>) -> Unit
    ) : Scope<T>(i18n) {
        fun arg(key: String, arg: Factory<T>) = add(key, arg)

        /** For `@key{...}`. */
        fun raw(key: String, value: () -> Any) = arg(key, Factory.Raw { rawArg(value()) })

        /** For `@key(...)`. */
        fun sub(key: String, value: () -> T) = arg(key, Factory.Substitution { subArg(value()) })

        // use a SAM constructor here because we need to provide a type for Factory's A
        /** For `@key[@_()]`. */
        fun tl(key: String, value: () -> Localizable<T>) = arg(key, Factory.Scoped { tlArg(value()) })

        /** For `@key[...]`. */
        fun map(key: String, value: MapScope<T>.() -> Unit) = arg(key, Factory.Scoped { mapArg(value) })

        /** For `@key[...]`. */
        fun list(key: String, value: ListScope<T>.() -> Unit) = arg(key, Factory.Scoped { listArg(value) })
    }

    // all non-lazy loaded
    class ListScope<T>(
        i18n: I18N<T>,
        val add: (Argument<T>) -> Unit
    ) : Scope<T>(i18n) {
        fun arg(arg: Argument<T>) = add(arg)

        /** For `@key{...}`. */
        fun raw(value: Any) = arg(rawArg(value))

        /** For `@key(...)`. */
        fun sub(value: T) = arg(subArg(value))

        /** For `@key(...)`. */
        fun tl(value: Localizable<T>) = arg(tlArg(value))

        /** For `@key[...]`. */
        fun map(value: MapScope<T>.() -> Unit) = arg(mapArg(value))

        /** For `@key[...]`. */
        fun list(value: ListScope<T>.() -> Unit) = arg(listArg(value))
    }
}
